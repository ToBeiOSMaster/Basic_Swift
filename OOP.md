# Object Oriented Programming



### Swift에서 OOP를 공부해야하는 이유

* 스위프트는 멀티패러다임 언어이지만 Foundation, UIKit 등 코코아 터치 프레임워크들은 기본적으로 OOP에 근간을 두고 있다
* Swift 내의 많은 라이브러리들의 소스가 왜 그런식으로 만들어졌는지 알 수 있고, 또 어떻게 이 원칙들을 녹여낼 수 있는지 좀 더 와닿게 이해할 수 있다



### OOP란?

* 객체 지향적인 프로그래밍. 즉, C언어같은 절차 지향적인 프로그래밍이 아닌 객체의 관점에서 프로그래밍을 한다는 것
* 객체를 기준으로 코드를 나누어 구현
* OOP는 절차지향에 비해서 사람의 사고방식과 더 가깝다.
* OOP는 객체들의 유기적인 관계를 통해서 프로세스가 진행된다.
* 애플리케이션을 구성하는 요소들을 객체로 바라보고, 객체들을 유기적으로 연결하여 프로그래밍 하는 것을 말한다.

### OOP 구성요소

* **클래스(class)**

  - 같은 종류의 집단에 속하는 속성과 행위를 정의한 것
  - 기본적인 사용자 정의 데이터형

  - 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것

* **객체(Object)**

  - 클래스의 인스턴스
  - 자신 고유의 속성을 가지며 클래스에서 정의한 행위를 수행할 수 있다
  - 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용한다
  - 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것

* **메서드(Method), 메시지(Message)**

  * 객체에 명령을 내리는 메시지
  * 메서드는 한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는 데 사용
  * 객체 간의 통신은 메시지를 통해 이루어진다



### OOP 특징

1. 추상화
   * 대상의 불필요한 부분을 무시하며 복잡성을 줄이고 목적에 집중할 수 있도록 단순화 시키는 것
   * UIViewController Class를 상속받아서 ViewController 를만들 수 있다
   * 추상적이고 넓은 범위의 UIViewController을 목적에 맞게 구체화시켜서 사용하는 것

2. 캡슐화
   * 객체 상태를 나타내는 속성 정보를 **private** 하게 관리 하는 것
   * 메세지를 같은 요청을 보내어 그 응답에 의해 객체의 상태를 변경하게 하는 것

3. 상속성
   * 하나의 클래스의 특징(부모 클래스)을 다른 클래스가 물려받아 그 속성과 기능을 동일하게 사용하는 것
   * 상속은 수직확장, Extension은 수평 확장

4. 다향성
   * 다형성이란 말 그대로 다양한 형태로 존재할 수 있다는 것
   * **Overriding**과 **Overloading**을 통하여, 동일한 요청에 대해 각각 다른 방식으로 응답할 수 있도록 만드는 것



### SOLID 원칙

1. 단일책임의 원칙(SRP : Single Responsibility Principle)
   * 하나의 객체는 하나의 책임을 가져야한다
   * 하나의 class가 여러 기능을 담당하면 안된다는 것
   * 책임을 클래스에 넘겨주는 식으로 작성하면 하위 핸들러들의 테스트도 용이해지게 됨

2. 개방-폐쇠의 원칙(OCP : Open Closed Principle)
   * 소프트웨어 엔티들은 확장에는 열려 있어야하지만 변경에는 닫혀있어야한다
   * **확장에 열려있다** :  클래스의 기능을 확장할 수 있다
   *  **변경에 닫혀있다** : 기존에 구현되어 있는 것들을 바꾸지 않고 클래스를 확장할 수 있어야 한다
   * ***<u>Protocol을 새로 만듬으로써</u>*** 해결할 수 있다 (= 추상화) 
3. 리스코프치환원칙(LSP : The Liskov Substitution Principle)
   * 상위 타입과 하위 타입 사이에서, 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 상위 타입)의 객체를 하위 타입로 교체할 수 있어야 한다
   * 상위 클래스의 자리에 하위 클래스를 치환해도 문제 없이 수행되어야 한다
   * Protocol을 만들어줌으로써 해결
4. 인터페이스분리원칙(ISP : The Interface Segregation Principle)
   * 사용하지 않는 인터페이스에 의존해서는 안된다
   * 불필요한 인터페이스 요소들을 포함시키지 말라
5. 의존관계의 역전 원칙(DIP : Dependency Inversion Principle)
   * 고차원의 모듈들은 하위 모듈에 의존하면 안된다
   * 추상 개념은 세부 사항에 의존하면 안된다
   * 복잡한 것을 제쳐두고, 핵심이 되는 요소만 가져다가 간결하게 보기 쉽게 만드는 것

### SOLID 원칙을 지켜야하는 이유

* **Fragility**: 작은 변화가 버그를 일으킬 수 있는데, 테스트가 용이하지 않아 미리 파악하기 어려운 것
* **Immobility**: 재사용성의 저하. 불필요하게 묶인(coupled) 의존성 때문에 재사용성이 낮아진다
* **Ridgidity**: 여러 곳에 묶여 있어서 작은 변화에도 많은 곳에서 변화(노력)가 필요하다





